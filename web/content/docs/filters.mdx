---
title: Filters
description: Advanced filtering and query operators
---

import { Accordion, Accordions } from 'fumadocs-ui/components/accordion';
import { TypeTable } from 'fumadocs-ui/components/type-table';

# Filters

The `where` clause allows you to filter records with powerful operators. All filters are type-safe and composable.

## Basic Filtering

### equals

Match exact values:

```ts
// String equality
const users = await collections.users.findMany({
  where: {
    status: { equals: 'active' }
  }
})

// Number equality
const posts = await collections.posts.findMany({
  where: {
    views: { equals: 1000 }
  }
})

// Boolean equality
const publishedPosts = await collections.posts.findMany({
  where: {
    published: { equals: true }
  }
})
```

### not

Invert a condition:

```ts
// Not equal
const users = await collections.users.findMany({
  where: {
    status: { not: 'inactive' }
  }
})

// Not null
const usersWithEmail = await collections.users.findMany({
  where: {
    email: { not: null }
  }
})
```

## Comparison Operators

### Number Comparisons

```ts
const posts = await collections.posts.findMany({
  where: {
    views: {
      gt: 100      // Greater than
    }
  }
})

const posts = await collections.posts.findMany({
  where: {
    views: {
      gte: 100     // Greater than or equal
    }
  }
})

const posts = await collections.posts.findMany({
  where: {
    views: {
      lt: 1000     // Less than
    }
  }
})

const posts = await collections.posts.findMany({
  where: {
    views: {
      lte: 1000    // Less than or equal
    }
  }
})
```

Available comparison operators:

<TypeTable
  type={{
    gt: {
      description: 'Greater than',
      type: 'number',
    },
    gte: {
      description: 'Greater than or equal',
      type: 'number',
    },
    lt: {
      description: 'Less than',
      type: 'number',
    },
    lte: {
      description: 'Less than or equal',
      type: 'number',
    },
  }}
/>

## String Operators

### contains

Substring match (case-sensitive):

```ts
const posts = await collections.posts.findMany({
  where: {
    title: { contains: 'tutorial' }
  }
})
```

### startsWith

Match strings starting with a value:

```ts
const users = await collections.users.findMany({
  where: {
    email: { startsWith: 'admin' }
  }
})
```

### endsWith

Match strings ending with a value:

```ts
const users = await collections.users.findMany({
  where: {
    email: { endsWith: '@example.com' }
  }
})
```

## Array Operators

### in

Match any value in an array:

```ts
const users = await collections.users.findMany({
  where: {
    status: { in: ['active', 'pending'] }
  }
})
```

### notIn

Exclude values in an array:

```ts
const users = await collections.users.findMany({
  where: {
    status: { notIn: ['deleted', 'banned'] }
  }
})
```

### isEmpty

Check if array field is empty:

```ts
const posts = await collections.posts.findMany({
  where: {
    tags: { isEmpty: true }
  }
})
```

### has

Check if array contains a value:

```ts
const posts = await collections.posts.findMany({
  where: {
    tags: { has: 'typescript' }
  }
})
```

### hasSome

Check if array contains any of the values:

```ts
const posts = await collections.posts.findMany({
  where: {
    tags: { hasSome: ['typescript', 'javascript'] }
  }
})
```

### hasEvery

Check if array contains all values:

```ts
const posts = await collections.posts.findMany({
  where: {
    tags: { hasEvery: ['typescript', 'nodejs'] }
  }
})
```

## Null Checks

### isNull

Match null values:

```ts
const users = await collections.users.findMany({
  where: {
    bio: { isNull: true }
  }
})
```

### isNotNull

Match non-null values:

```ts
const users = await collections.users.findMany({
  where: {
    bio: { isNotNull: true }
  }
})
```

## Date Operators

### before/after

Filter dates:

```ts
const recentPosts = await collections.posts.findMany({
  where: {
    createdAt: { after: new Date('2024-01-01') }
  }
})

const oldPosts = await collections.posts.findMany({
  where: {
    createdAt: { before: new Date('2023-01-01') }
  }
})
```

### Date Comparisons

```ts
const posts = await collections.posts.findMany({
  where: {
    createdAt: {
      gte: new Date('2024-01-01'),
      lt: new Date('2024-02-01')
    }
  }
})
```

## Logical Operators

### AND

All conditions must be true (default behavior):

```ts
const users = await collections.users.findMany({
  where: {
    AND: [
      { status: { equals: 'active' } },
      { age: { gte: 18 } },
      { country: { equals: 'US' } }
    ]
  }
})
```

Shorthand (multiple conditions):

```ts
const users = await collections.users.findMany({
  where: {
    status: { equals: 'active' },
    age: { gte: 18 },
    country: { equals: 'US' }
  }
})
```

### OR

At least one condition must be true:

```ts
const posts = await collections.posts.findMany({
  where: {
    OR: [
      { title: { contains: 'typescript' } },
      { title: { contains: 'javascript' } },
      { title: { contains: 'nodejs' } }
    ]
  }
})
```

### NOT

Invert conditions:

```ts
const users = await collections.users.findMany({
  where: {
    NOT: {
      status: { equals: 'deleted' }
    }
  }
})
```

### Combining Logical Operators

```ts
const posts = await collections.posts.findMany({
  where: {
    AND: [
      { published: { equals: true } },
      {
        OR: [
          { title: { contains: 'tutorial' } },
          { tags: { has: 'beginner' } }
        ]
      }
    ]
  }
})
```

## Nested Filters

Filter on nested object fields:

```ts
const users = await collections.users.findMany({
  where: {
    'settings.theme': { equals: 'dark' },
    'settings.notifications.email': { equals: true }
  }
})
```

## Relation Filters

Filter based on related records:

<Accordions type="multiple">
  <Accordion title="One-to-Many Relations">

```ts
// Get posts by author
const posts = await collections.posts.findMany({
  where: {
    authorId: { equals: 1 }
  }
})

// Using relation syntax
const posts = await collections.posts.findMany({
  where: {
    author: {
      email: { equals: 'author@example.com' }
    }
  }
})
```

  </Accordion>

  <Accordion title="Many-to-Many Relations">

```ts
// Get posts with specific category
const posts = await collections.posts.findMany({
  where: {
    categories: {
      some: {
        slug: { equals: 'typescript' }
      }
    }
  }
})

// Get posts with all specified categories
const posts = await collections.posts.findMany({
  where: {
    categories: {
      every: {
        slug: { in: ['typescript', 'nodejs'] }
      }
    }
  }
})

// Get posts without a category
const posts = await collections.posts.findMany({
  where: {
    categories: {
      none: {
        slug: { equals: 'draft' }
      }
    }
  }
})
```

  </Accordion>
</Accordions>

## Complex Examples

### Advanced Search

```ts
const searchPosts = async (query: string, tags?: string[]) => {
  return await collections.posts.findMany({
    where: {
      published: { equals: true },
      OR: [
        { title: { contains: query } },
        { content: { contains: query } }
      ],
      ...(tags && {
        tags: { hasEvery: tags }
      })
    },
    orderBy: {
      createdAt: 'desc'
    }
  })
}
```

### Date Range

```ts
const getPostsInRange = (start: Date, end: Date) => {
  return collections.posts.findMany({
    where: {
      createdAt: {
        gte: start,
        lte: end
      }
    }
  })
}
```

### Filter by Computed Fields

```ts
// Find popular posts (high views and recent)
const popularPosts = await collections.posts.findMany({
  where: {
    AND: [
      { views: { gte: 1000 } },
      { createdAt: { after: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) } }
    ]
  }
})
```

## Performance Tips

1. **Use indexes** on frequently filtered fields
2. **Use specific operators** when possible (e.g., `equals` over `contains`)
3. **Limit OR conditions** - they can be slow
4. **Use pagination** with filters to avoid large result sets
5. **Consider database indexes** for complex filters

```ts
// In your collection definition
export const users = collection({
  slug: 'users',
  fields: {
    email: field({
      type: email(),
      indexed: true // Add index for filtering
    }),
    status: field({
      type: enumField(['active', 'inactive']),
      indexed: true // Add index for filtering
    })
  }
})
```

## Operator Reference

<TypeTable
  type={{
    equals: {
      description: 'Exact match',
      type: 'T',
    },
    not: {
      description: 'Not equal to',
      type: 'T',
    },
    in: {
      description: 'Match any in array',
      type: 'T[]',
    },
    notIn: {
      description: 'Not in array',
      type: 'T[]',
    },
    gt: {
      description: 'Greater than (numbers, dates)',
      type: 'number | Date',
    },
    gte: {
      description: 'Greater than or equal',
      type: 'number | Date',
    },
    lt: {
      description: 'Less than (numbers, dates)',
      type: 'number | Date',
    },
    lte: {
      description: 'Less than or equal',
      type: 'number | Date',
    },
    contains: {
      description: 'Contains substring',
      type: 'string',
    },
    startsWith: {
      description: 'Starts with string',
      type: 'string',
    },
    endsWith: {
      description: 'Ends with string',
      type: 'string',
    },
    AND: {
      description: 'All conditions must be true',
      type: 'WhereClause[]',
    },
    OR: {
      description: 'At least one condition must be true',
      type: 'WhereClause[]',
    },
    NOT: {
      description: 'Invert condition',
      type: 'WhereClause',
    },
    isNull: {
      description: 'Is null',
      type: 'boolean',
    },
    isNotNull: {
      description: 'Is not null',
      type: 'boolean',
    },
  }}
/>

## Next Steps

- [Queries](/docs/queries) - Basic CRUD operations
- [Querying Relations](/docs/relations-query) - Filter by related records
- [Pagination](/docs/pagination) - Pagination and sorting strategies
