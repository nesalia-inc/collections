---
title: Querying Relations
description: Loading and filtering related data
---

import { Accordion, Accordions } from 'fumadocs-ui/components/accordion';
import { TypeTable } from 'fumadocs-ui/components/type-table';

# Querying Relations

Relations allow you to work with related data across collections. Learn how to load, filter, and manipulate relationships in your queries.

## Overview

When you define relations between collections, you can query them using:

<TypeTable
  type={{
    include: {
      description: 'Load related records',
      type: 'IncludeClause',
    },
    select: {
      description: 'Select specific fields from related records',
      type: 'SelectClause',
    },
    where: {
      description: 'Filter by related records',
      type: 'WhereClause',
    },
  }}
/>

## Loading Relations

### include

Use `include` to load related records:

```ts
const posts = await collections.posts.findMany({
  include: {
    author: true  // Load the author relation
  }
})

// Result type:
// {
//   id: number
//   title: string
//   authorId: number
//   author: {
//     id: number
//     name: string
//     email: string
//   }
// }[]
```

### Nested Relations

Load deeply nested relations:

```ts
const posts = await collections.posts.findMany({
  include: {
    author: {
      include: {
        profile: true  // Load author's profile
      }
    },
    comments: {
      include: {
        author: true  // Load comment authors
      }
    }
  }
})
```

### Selecting Related Fields

Choose specific fields from related records:

```ts
const posts = await collections.posts.findMany({
  include: {
    author: {
      select: {
        name: true,
        email: true
        // Don't load other fields
      }
    }
  }
})
```

## Relation Types

<Accordions type="multiple">
  <Accordion title="One-to-One Relations">

Load a single related record:

```ts
// Collection definition
export const users = collection({
  slug: 'users',
  fields: {
    profile: field({
      type: relation('profiles', { singular: true })
    })
  }
})

// Query
const users = await collections.users.findMany({
  include: {
    profile: true
  }
})

// Result
// {
//   id: number
//   name: string
//   profile: {
//     id: number
//     bio: string
//   } | null  // Can be null
// }[]
```

  </Accordion>

  <Accordion title="One-to-Many Relations">

Load multiple related records:

```ts
// Collection definition
export const posts = collection({
  slug: 'posts',
  fields: {
    comments: field({
      type: relation('comments', { many: true })
    })
  }
})

// Query
const posts = await collections.posts.findMany({
  include: {
    comments: true
  }
})

// Result
// {
//   id: number
//   title: string
//   comments: {
//     id: number
//     content: string
//   }[]
// }[]
```

  </Accordion>

  <Accordion title="Many-to-Many Relations">

Load records from join tables:

```ts
// Collection definition
export const posts = collection({
  slug: 'posts',
  fields: {
    categories: field({
      type: relation('categories', {
        many: true,
        through: 'postCategories'
      })
    })
  }
})

// Query
const posts = await collections.posts.findMany({
  include: {
    categories: true
  }
})

// Result
// {
//   id: number
//   title: string
//   categories: {
//     id: number
//     name: string
//     slug: string
//   }[]
// }[]
```

  </Accordion>

  <Accordion title="Reverse Relations">

Load records that reference this record:

```ts
// Collection definition
export const posts = collection({
  slug: 'posts',
  fields: {
    comments: field({
      type: reverseRelation({
        collection: 'comments',
        via: 'postId'
      })
    })
  }
})

// Query
const posts = await collections.posts.findMany({
  include: {
    comments: true
  }
})

// Loads all comments where postId matches this post's id
```

  </Accordion>
</Accordions>

## Filtering Relations

### Filtering by Related Records

Find records based on their relations:

```ts
// Find posts by a specific author
const posts = await collections.posts.findMany({
  where: {
    author: {
      email: { equals: 'author@example.com' }
    }
  }
})

// Find posts with specific category
const posts = await collections.posts.findMany({
  where: {
    categories: {
      some: {
        slug: { equals: 'typescript' }
      }
    }
  }
})
```

### Relation Filter Operators

<TypeTable
  type={{
    some: {
      description: 'At least one related record matches',
      type: 'WhereClause',
    },
    every: {
      description: 'All related records match',
      type: 'WhereClause',
    },
    none: {
      description: 'No related records match',
      type: 'WhereClause',
    },
    is: {
      description: 'Related record equals value (one-to-one)',
      type: 'WhereClause',
    },
  }}
/>

### some - At Least One Match

```ts
// Posts with at least one published comment
const posts = await collections.posts.findMany({
  where: {
    comments: {
      some: {
        status: { equals: 'published' }
      }
    }
  }
})

// Posts with at least one "typescript" tag
const posts = await collections.posts.findMany({
  where: {
    tags: {
      some: {
        name: { equals: 'typescript' }
      }
    }
  }
})
```

### every - All Must Match

```ts
// Posts where ALL comments are published
const posts = await collections.posts.findMany({
  where: {
    comments: {
      every: {
        status: { equals: 'published' }
      }
    }
  }
})

// Posts with exactly these tags (no other tags)
const posts = await collections.posts.findMany({
  where: {
    tags: {
      every: {
        name: { in: ['typescript', 'nodejs'] }
      }
    }
  }
})
```

### none - None Must Match

```ts
// Posts with NO deleted comments
const posts = await collections.posts.findMany({
  where: {
    comments: {
      none: {
        status: { equals: 'deleted' }
      }
    }
  }
})

// Posts without "deprecated" tag
const posts = await collections.posts.findMany({
  where: {
    tags: {
      none: {
        name: { equals: 'deprecated' }
      }
    }
  }
})
```

## Advanced Relation Queries

### Filtering and Loading Together

```ts
const posts = await collections.posts.findMany({
  where: {
    // Filter by relation
    author: {
      status: { equals: 'active' }
    }
  },
  include: {
    // Load the relation
    author: {
      select: {
        name: true,
        email: true
      }
    }
  }
})
```

### Counting Relations

```ts
const posts = await collections.posts.findMany({
  include: {
    _count: {
      select: {
        comments: true
      }
    }
  }
})

// Result includes:
// {
//   id: number
//   title: string
//   _count: {
//     comments: number
//   }
// }
```

### Ordering by Relations

```ts
// Order posts by comment count
const posts = await collections.posts.findMany({
  include: {
    _count: {
      select: {
        comments: true
      }
    }
  },
  orderBy: {
    _count: {
      comments: 'desc'
    }
  }
})
```

### Limiting Included Relations

Limit the number of related records loaded:

```ts
const posts = await collections.posts.findMany({
  include: {
    comments: {
      take: 5,  // Only load 5 most recent comments
      orderBy: {
        createdAt: 'desc'
      }
    }
  }
})
```

### Filtering Included Relations

Apply filters to loaded relations:

```ts
const posts = await collections.posts.findMany({
  include: {
    comments: {
      where: {
        status: { equals: 'published' }  // Only load published comments
      },
      orderBy: {
        createdAt: 'desc'
      }
    }
  }
})
```

## Real-World Examples

### Blog with Author and Comments

```ts
// Get published posts with authors and published comments
const getBlogPosts = async () => {
  return await collections.posts.findMany({
    where: {
      published: { equals: true }
    },
    include: {
      author: {
        select: {
          name: true,
          avatar: true
        }
      },
      comments: {
        where: {
          status: { equals: 'published' }
        },
        orderBy: {
          createdAt: 'desc'
        },
        take: 10
      },
      _count: {
        select: {
          comments: true
        }
      }
    },
    orderBy: {
      publishedAt: 'desc'
    }
  })
}
```

### E-commerce Product with Categories and Reviews

```ts
// Get product with all related data
const getProduct = async (slug: string) => {
  return await collections.products.findFirst({
    where: {
      slug: { equals: slug }
    },
    include: {
      categories: true,
      reviews: {
        where: {
          approved: { equals: true }
        },
        orderBy: {
          helpful: 'desc'
        },
        take: 10
      },
      variants: {
        where: {
          inStock: { equals: true }
        }
      }
    }
  })
}
```

### User Dashboard

```ts
// Get user with all their data
const getUserDashboard = async (userId: number) => {
  return await collections.users.findUnique({
    where: { id: userId },
    include: {
      profile: true,
      posts: {
        where: {
          status: { equals: 'published' }
        },
        orderBy: {
          createdAt: 'desc' },
        take: 5
      },
      comments: {
        orderBy: {
          createdAt: 'desc'
        },
        take: 10
      },
      _count: {
        select: {
          posts: true,
          comments: true
        }
      }
    }
  })
}
```

## Performance Considerations

### N+1 Query Problem

❌ **Bad** - N+1 queries:

```ts
const posts = await collections.posts.findMany()
// N queries to load authors
for (const post of posts) {
  const author = await collections.users.findUnique({
    where: { id: post.authorId }
  })
}
```

✅ **Good** - Single query with include:

```ts
const posts = await collections.posts.findMany({
  include: {
    author: true
  }
})
```

### Loading Strategies

<Accordions type="multiple">
  <Accordion title="Eager Loading">

Load everything upfront:

```ts
const posts = await collections.posts.findMany({
  include: {
    author: true,
    comments: true,
    categories: true
  }
})
```

**Use when:** You always need the related data

  </Accordion>

  <Accordion title="Lazy Loading">

Load relations only when needed:

```ts
// First, get posts
const posts = await collections.posts.findMany()

// Later, load authors for specific posts
const authors = await collections.users.findMany({
  where: {
    id: { in: posts.map(p => p.authorId) }
  }
})
```

**Use when:** Related data is rarely needed

  </Accordion>

  <Accordion title="Selective Loading">

Load only what you need:

```ts
const posts = await collections.posts.findMany({
  include: {
    author: {
      select: {
        name: true  // Only load name, not email, etc.
      }
    }
  }
})
```

**Use when:** You only need specific fields

  </Accordion>
</Accordions>

## Best Practices

1. **Use include** instead of separate queries to avoid N+1 problems
2. **Select only needed fields** from relations to reduce data transfer
3. **Limit included relations** with `take` when appropriate
4. **Filter included relations** to load only relevant data
5. **Count relations** with `_count` instead of loading all records
6. **Index foreign keys** for better join performance

```ts
// Add index for better relation query performance
export const posts = collection({
  slug: 'posts',
  fields: {
    authorId: field({
      type: relation('users'),
      indexed: true  // Index for faster joins
    })
  }
})
```

## Next Steps

- [Queries](/docs/queries) - Basic CRUD operations
- [Filters](/docs/filters) - Advanced filtering operators
- [Pagination](/docs/pagination) - Pagination and sorting
