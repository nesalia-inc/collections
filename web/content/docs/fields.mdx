---
title: Fields
description: Comprehensive guide to field configuration, validation, and customization
---

import { Accordion, Accordions } from 'fumadocs-ui/components/accordion';
import { TypeTable } from 'fumadocs-ui/components/type-table';

# Fields

Fields are the building blocks of Collections. They define the schema of your data, control how it's validated, determine how it's stored in the database, and govern how it appears in your APIs.

Fields can be endlessly customized in their appearance and behavior without affecting their underlying data structure. They are designed to be composable, extensible, and type-safe.

## Overview

Each field combines:

1. **A Field Type** - Determines what kind of data it accepts (text, number, relation, etc.)
2. **Configuration** - Labels, descriptions, defaults, validation rules
3. **Behavior** - Hooks, computed values, conditional logic
4. **Presentation** - Admin UI options, custom components

There are three main categories of fields in Collections:

- **Data Fields** - Store data in the database
- **Computed Fields** - Derive values from other fields
- **Relation Fields** - Link to other collections

## Basic Field Syntax

Fields are defined within a collection's `fields` property:

```ts
import { collection, field } from '@deessejs/collections'
import { text, email } from '@deessejs/collections/fields'

export const users = collection({
  slug: 'users',

  fields: {
    name: field({
      type: text({ min: 2, max: 100 }),
      label: 'Full Name',
      required: true
    }),

    email: field({
      type: email(),
      label: 'Email Address',
      unique: true,
      required: true
    })
  }
})
```

## Field Configuration

Every field is configured with an object containing its type and options:

<TypeTable
  type={{
    type: {
      description: 'Required. The field type that determines what data it accepts',
      type: 'FieldType',
    },
    label: {
      description: 'Human-readable label used in API responses, error messages, and admin UI. Can be a string or i18n object',
      type: 'string | Record<string, string>',
    },
    description: {
      description: 'Additional context about the field shown in admin panels and API documentation',
      type: 'string | Record<string, string>',
    },
    default: {
      description: 'Default value applied on create operations. Can be a static value or function',
      type: 'T | () => T',
    },
    required: {
      description: 'Whether the field is required (cannot be null or undefined)',
      type: 'boolean',
      default: 'false',
    },
    unique: {
      description: 'Add a unique constraint to the field in the database',
      type: 'boolean',
      default: 'false',
    },
    indexed: {
      description: 'Add a database index for faster queries on this field',
      type: 'boolean',
      default: 'false',
    },
    nullable: {
      description: 'Allow null values for this field',
      type: 'boolean',
      default: 'true',
    },
    hidden: {
      description: 'Hide field from auto-generated forms and API responses',
      type: 'boolean',
      default: 'false',
    },
    messages: {
      description: 'Custom validation messages with i18n support',
      type: 'Record<string, string | Record<string, string>>',
    },
    validate: {
      description: 'Custom validation function to run additional checks',
      type: '(value: T) => true | string',
    },
    computed: {
      description: 'Configuration for computed fields that derive values from other fields',
      type: '{ from: string[], compute: (data) => T }',
    },
    admin: {
      description: 'Admin UI configuration options',
      type: 'AdminOptions',
    },
    hooks: {
      description: 'Field-level hooks for lifecycle events',
      type: 'FieldHooks',
    },
  }}
/>

Example:

```ts
field({
  type: text({ min: 2, max: 100 }),
  label: 'Name',
  description: 'Enter your full name',
  default: 'Anonymous',
  required: true,
  unique: true,
  indexed: true
})
```

## Field Categories

<Accordions type="multiple">
  <Accordion title="Data Fields">

Data Fields store data in the database. They have a `type` property that determines their behavior.

Available Data Fields:

<TypeTable
  type={{
    text: {
      description: 'Simple text input that saves a string',
      type: 'text',
    },
    number: {
      description: 'Saves numeric values with optional min/max constraints',
      type: 'number',
    },
    boolean: {
      description: 'Checkbox that saves boolean true/false values',
      type: 'boolean',
    },
    email: {
      description: 'Ensures the value is a properly formatted email address',
      type: 'email',
    },
    url: {
      description: 'Validates and stores URL strings',
      type: 'url',
    },
    timestamp: {
      description: 'Renders a date picker and saves a timestamp',
      type: 'Date',
    },
    enumField: {
      description: 'Renders a select dropdown with predefined options',
      type: 'T[]',
    },
    array: {
      description: 'For repeating content, supports nested types',
      type: 'T[]',
    },
    json: {
      description: 'Renders a JSON editor interface that saves a JSON object',
      type: 'object',
    },
    relation: {
      description: 'Assign relationships to other collections',
      type: 'Relation',
    },
  }}
/>

Data fields automatically:
- Generate TypeScript types
- Validate input based on the field type
- Create corresponding database columns via Drizzle
- Provide runtime type safety

  </Accordion>

  <Accordion title="Computed Fields">

Computed fields display data that is not stored in the database, but is derived or calculated from other fields.

```ts
fields: {
  firstName: field({ type: text() }),
  lastName: field({ type: text() }),

  fullName: field({
    type: text(),
    computed: {
      from: ['firstName', 'lastName'],
      compute: ({ firstName, lastName }) => {
        return `${firstName} ${lastName}`
      }
    }
  })
}
```

Computed fields are ideal for:
- Displaying read-only calculated data
- Formatting values from other fields
- Creating aliases for complex field paths
- Performance optimization for frequently accessed combinations

  </Accordion>

  <Accordion title="Relation Fields">

Relation fields link documents across collections.

<TypeTable
  type={{
    'One-to-One': {
      description: 'Single relationship between two documents',
      type: "relation('target', { singular: true })",
    },
    'One-to-Many': {
      description: 'Foreign key relationship (many documents can reference one)',
      type: "relation('target')",
    },
    'Many-to-Many': {
      description: 'Relationship through a join table',
      type: "relation('target', { many: true, through: 'joinTable' })",
    },
    'Reverse Relation': {
      description: 'Virtual field to access related documents',
      type: "reverseRelation({ collection: 'target', via: 'field' })",
    },
  }}
/>

Example:

```ts
// One-to-One
profile: field({
  type: relation('profiles', { singular: true })
})

// One-to-Many (foreign key)
authorId: field({
  type: relation('users')
})

// Many-to-Many (through join table)
categories: field({
  type: relation('categories', {
    many: true,
    through: 'postCategories'
  })
})

// Reverse relation (virtual)
comments: field({
  type: reverseRelation({
    collection: 'comments',
    via: 'postId'
  })
})
```

  </Accordion>
</Accordions>

## Field Properties

### name (implicit)

The field name is the key used in the fields object. This is the property name that will be used in TypeScript types and database columns:

```ts
fields: {
  // 'firstName' is the field name
  firstName: field({ type: text() })
}

// Usage:
user.firstName // Type-safe access
```

Field names must be unique within a collection.

### type

Required. Defines the field type:

```ts
type: text({ min: 3, max: 255 })
type: email()
type: enumField(['draft', 'published'])
type: relation('users')
```

See [Field Types](/docs/field-types) for all available types.

### label

Human-readable label for the field. Used in API responses, error messages, and Admin UI:

```ts
label: 'Email Address'
```

With i18n:

```ts
label: {
  en: 'Email Address',
  fr: 'Adresse e-mail',
  es: 'Dirección de correo'
}
```

If not provided, the field name will be formatted as the label (e.g., `firstName` → "First Name").

### description

Additional context about the field. Shown in admin panels and API documentation:

```ts
description: 'We will never share your email with third parties'
```

With i18n:

```ts
description: {
  en: 'A short biography',
  fr: 'Une courte biographie'
}
```

### default

Default value for the field. Applied on create operations if no value is provided:

```ts
// Static value
status: field({
  type: enumField(['draft', 'published']),
  default: 'draft'
})

// Function
createdAt: field({
  type: timestamp(),
  default: () => new Date()
})
```

### required

Make a field required (cannot be null or undefined):

```ts
email: field({
  type: email(),
  required: true
})
```

Required fields are validated both at the API level and in the database schema.

### unique

Add a unique constraint to the field in the database:

```ts
username: field({
  type: text(),
  unique: true
})
```

### indexed

Add a database index for faster queries:

```ts
email: field({
  type: email(),
  indexed: true
})
```

Use indexed on fields that are frequently used in `where` clauses or for sorting.

### nullable

Allow null values:

```ts
middleName: field({
  type: text(),
  nullable: true
})
```

Most fields are nullable by default. Use `required: true` to enforce non-null values.

### hidden

Hide field from auto-generated forms and API responses:

```ts
apiKey: field({
  type: text(),
  hidden: true
})
```

Hidden fields are still stored in the database but not exposed publicly.

## Validation

### Built-in Validation

Fields are automatically validated based on their type:

```ts
// Text validation
name: field({
  type: text({ min: 2, max: 100 })
})

// Email validation
email: field({
  type: email()
})

// Number validation
age: field({
  type: number({ min: 0, max: 120 })
})
```

### Custom Validation

Add custom validation logic with the `validate` function:

```ts
password: field({
  type: text({ min: 8 }),
  validate: (value) => {
    if (!/[A-Z]/.test(value)) {
      throw new Error('Password must contain at least one uppercase letter')
    }
    if (!/[0-9]/.test(value)) {
      throw new Error('Password must contain at least one number')
    }
    if (!/[!@#$%^&*]/.test(value)) {
      throw new Error('Password must contain at least one special character')
    }
    return true
  }
})
```

### Validation Messages

Customize error messages with i18n support:

```ts
email: field({
  type: email(),
  messages: {
    required: {
      en: 'Email is required',
      fr: 'Email est requis',
      es: 'El correo electrónico es obligatorio'
    },
    invalid: {
      en: 'Please enter a valid email address',
      fr: 'Veuillez entrer une adresse e-mail valide',
      es: 'Por favor, introduzca una dirección de correo electrónico válida'
    }
  }
})
```

Available message keys:

<TypeTable
  type={{
    required: {
      description: 'Field is required but missing',
      type: 'string',
    },
    invalid: {
      description: 'Field value is invalid',
      type: 'string',
    },
    tooShort: {
      description: 'Text is shorter than minimum',
      type: 'string',
    },
    tooLong: {
      description: 'Text is longer than maximum',
      type: 'string',
    },
    min: {
      description: 'Number is less than minimum',
      type: 'string',
    },
    max: {
      description: 'Number is greater than maximum',
      type: 'string',
    },
  }}
/>

## Computed Fields

Computed fields derive values from other fields without storing them in the database:

### Basic Computed Field

```ts
fields: {
  price: field({ type: number() }),
  taxRate: field({ type: number(), default: 0.1 }),

  total: field({
    type: number(),
    computed: {
      from: ['price', 'taxRate'],
      compute: ({ price, taxRate }) => {
        return price + (price * taxRate)
      }
    }
  })
}
```

### Computed Fields with Transformations

```ts
fields: {
  firstName: field({ type: text() }),
  lastName: field({ type: text() }),

  // Create URL-safe slug
  slug: field({
    type: text(),
    computed: {
      from: ['firstName', 'lastName'],
      compute: ({ firstName, lastName }) => {
        return `${firstName.toLowerCase()}-${lastName.toLowerCase()}`
      }
    }
  })
}
```

Computed fields are:
- Read-only (cannot be set directly)
- Calculated on every read operation
- Not stored in the database
- Available in API responses

## Field Modifiers

Chain modifiers to fields for cleaner syntax:

```ts
email: field({
  type: email()
})
.required()
.unique()
.indexed()
```

Available modifiers:
- `.required()` - Make field required
- `.unique()` - Add unique constraint
- `.indexed()` - Add database index
- `.default(value)` - Set default value
- `.validate(fn)` - Add custom validation

## Admin Options

Customize how fields appear and behave in admin panels:

```ts
title: field({
  type: text(),
  admin: {
    placeholder: 'Enter your title...',
    helpText: 'Keep it under 60 characters for best display',
    width: '50%',
    style: {
      fontWeight: 'bold'
    },
    className: 'custom-title-field',
    readOnly: false,
    disabled: false
  }
})
```

Available admin options:

<TypeTable
  type={{
    placeholder: {
      description: 'Placeholder text for input',
      type: 'string',
    },
    helpText: {
      description: 'Additional help text displayed below the field',
      type: 'string',
    },
    width: {
      description: 'CSS width value (e.g. "50%", "200px")',
      type: 'string',
    },
    style: {
      description: 'Inline CSS styles',
      type: 'Record<string, string>',
    },
    className: {
      description: 'CSS class name',
      type: 'string',
    },
    readOnly: {
      description: 'Disable editing (still shows value)',
      type: 'boolean',
      default: 'false',
    },
    disabled: {
      description: 'Completely disable the field',
      type: 'boolean',
      default: 'false',
    },
    position: {
      description: 'Render in sidebar ("sidebar" or undefined)',
      type: 'string',
    },
  }}
/>

## Conditional Logic

Show or hide fields based on other field values:

```ts
fields: {
  hasDiscount: field({
    type: boolean(),
    default: false
  }),

  discountPercentage: field({
    type: number({ min: 0, max: 100 }),
    admin: {
      condition: (data, siblingData) => {
        return siblingData.hasDiscount === true
      }
    }
  })
}
```

Condition function receives:
- `data` - The entire document's data
- `siblingData` - Only fields within the same parent
- `user` - Currently authenticated user (if available)

## Field-Level Hooks

Execute logic at specific points in a field's lifecycle:

```ts
fields: {
  slug: field({
    type: text(),
    hooks: {
      beforeCreate: [({ data, value }) => {
        // Auto-generate slug from title
        return slugify(data.title)
      }],

      beforeUpdate: [({ data, value }) => {
        // Only regenerate if title changed
        if (data.titleChanged) {
          return slugify(data.title)
        }
        return value
      }]
    }
  })
}
```

Available field-level hooks:
- `beforeCreate` - Before field is saved on create
- `afterCreate` - After field is saved on create
- `beforeUpdate` - Before field is saved on update
- `afterUpdate` - After field is saved on update

## Complete Example

<Accordions type="single">
  <Accordion title="Complete User Collection Example">

Here's a comprehensive example showing many field features:

```ts
import { collection, field } from '@deessejs/collections'
import { text, email, enumField, number, timestamp } from '@deessejs/collections/fields'

export const users = collection({
  slug: 'users',

  fields: {
    // Basic required field
    name: field({
      type: text({ min: 2, max: 100 }),
      label: 'Full Name',
      description: 'Your legal name',
      required: true,
      indexed: true,
      admin: {
        placeholder: 'John Doe',
        helpText: 'This will appear on your public profile'
      }
    }),

    // Email with custom validation and messages
    email: field({
      type: email(),
      label: 'Email Address',
      description: 'We will never share your email',
      required: true,
      unique: true,
      indexed: true,
      validate: (value) => {
        // Additional business logic validation
        if (value.endsWith('@temp-mail.com')) {
          throw new Error('Temporary email addresses are not allowed')
        }
        return true
      },
      messages: {
        required: 'Email is required',
        invalid: 'Please enter a valid email address'
      },
      admin: {
        placeholder: 'you@example.com',
        helpText: 'Use your permanent email address'
      }
    }),

    // Enum with translated labels
    status: field({
      type: enumField(['active', 'inactive', 'suspended']),
      label: 'Account Status',
      default: 'active',
      enumLabels: {
        active: {
          en: 'Active',
          fr: 'Actif'
        },
        inactive: {
          en: 'Inactive',
          fr: 'Inactif'
        },
        suspended: {
          en: 'Suspended',
          fr: 'Suspendu'
        }
      }
    }),

    // Number with constraints
    age: field({
      type: number({ min: 13, max: 120 }),
      label: 'Age',
      required: true,
      validate: (value) => {
        if (value < 18) {
          throw new Error('You must be 18 or older to use this service')
        }
        return true
      },
      admin: {
        helpText: 'You must be 18 or older to register'
      }
    }),

    // Computed field
    accountAge: field({
      type: number(),
      label: 'Account Age (days)',
      computed: {
        from: ['createdAt'],
        compute: ({ createdAt }) => {
          const now = new Date()
          const created = new Date(createdAt)
          const diffTime = Math.abs(now - created)
          return Math.floor(diffTime / (1000 * 60 * 60 * 24))
        }
      }
    }),

    // Optional field with conditional display
    bio: field({
      type: text(),
      label: 'Biography',
      nullable: true,
      admin: {
        condition: (data) => data.status === 'active',
        placeholder: 'Tell us about yourself...',
        helpText: 'Maximum 500 characters'
      }
    }),

    // Auto-generated timestamps
    createdAt: field({
      type: timestamp(),
      label: 'Created At',
      default: () => new Date(),
      admin: {
        readOnly: true
      }
    }),

    updatedAt: field({
      type: timestamp(),
      label: 'Updated At',
      default: () => new Date(),
      admin: {
        readOnly: true
      }
    })
  }
})
```

  </Accordion>
</Accordions>

## Best Practices

1. **Use descriptive names** - Field names should be clear and consistent
2. **Provide labels** - Always include human-readable labels
3. **Add descriptions** - Help users understand what each field does
4. **Validate input** - Use built-in and custom validation
5. **Use i18n** - Make your fields accessible to international users
6. **Index strategically** - Add indexes to frequently queried fields
7. **Document computed fields** - Explain how computed values are derived
8. **Use conditionals** - Hide irrelevant fields to reduce complexity

## Next Steps

- [Field Types](/docs/field-types) - Explore all available field types
- [Collections](/docs/collections) - Learn about collections and advanced features
- [i18n](/docs/i18n) - Internationalization support
- [Plugins](/docs/plugins) - Extend functionality with plugins
